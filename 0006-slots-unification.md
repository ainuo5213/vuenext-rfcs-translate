# 摘要

统一普通插槽和作用域插槽。在V3版本中他们都是插槽而已

Unify the concepts of normal vs. scoped slots. They are all just slots in v3.

# 改动

- 普通插槽和作用域插槽的分离是以后新概念的作用域插槽的结果，他们在2.x版本中有不同的内部实现。但是，这种不同在技术上是没必要的。将这两者统一起来可以简化插槽的总体概念。

- 组件作者使用渲染函数不再担心同事处理`$slots`和`$scopedSlots`。

- 将所有插槽编译为函数在大型组件树中有更好的性能。

- 引用2.6版本的发布说明：

  > 普通插槽在父级的渲染周期中被渲染。当插槽的依赖项发生改变时，它会导致父组件和子组件重新渲染。在另一方面，作用域插槽被编译为内联函数，并在子组件渲染周期被调用。这意味着，所有数据依赖都由子组件收集，以获得更加精确的更新。在2.6版本中，我们引入了一项优化，进一步确保如果父组件仅使用作用域插槽时，父组件作用域依赖变化仅影响父组件而不再强制子组件更新。

# 详细设计

插槽统一化分为两个部分：

- 语法统一（2.6版本中的`v-slot`）
- 实现统一：将所有插槽编译为函数。
  - 现在`this.$slots`以函数的形式暴露插槽。
  - 移除`this.$scopedSlots`。
  - `this.$scopedSlots` removed.
  - 在2.x版本中，所有的插槽使用`v-slot`语法都在内部编译为了函数。`this.$scopedSlots`已经代理普通插槽并将他们暴露成了函数。

## 在渲染函数中使用

已有的渲染函数会仍然会支持。当传递子组件到组件时，同事支持虚拟节点和函数：

``` js
h(Comp, [
  h('div', this.msg)
])

// equivalent:
h(Comp, () => [
  h('div', this.msg)
])
```

除了 `Comp`, `this.$slots.default`也将是一个函数，并且返回相同的虚拟节点。但是，第二种会更加地高效，因为`this.msg`会被注册为子组件的依赖项。

具名插槽使用方法已改变——内容节点上不再使用`slot`的数据属性，而是通过第三个参数传递他们到子组件：

``` js
// 2.x
h(Comp, [
  h('div', { slot: 'foo' }, this.foo),
  h('div', { slot: 'bar' }, this.bar)
])

// 3.0
// 注意：`null`必传，否则会引起错误
h(Comp, null, {
  foo: () => h('div', this.foo),
  bar: () => h('div', this.bar)
})
```

### 进一步手动优化

注意，当父组件更新时，`Comp`总是被迫跟着刷新，因为如果没有编译，Vue就不会有足够的信息来告诉插槽是否改变。

编译器能检测`v-slot`和编译内容为函数，但是在渲染函数中这并不会自动运行。我们也可以像JSX babel插件中执行类似的优化。但是对于用户直接编写渲染函数，他们不需要在性能敏感例子中手动优化。

插槽也可以手动注解，这样Vue就不会在父组件更新时强制更新子组件：

``` js
h(Comp, null, {
  $stable: true,
  foo: () => h('div', this.foo),
  bar: () => h('div', this.bar)
})
```

# 采用策略

大部分改变已在2.6版本中发布。唯一剩下的就是移除`this.$scopedSlots`。实际上，目前2.6版本的`this.$scopedSlots`和3.0版本的`this.$slots`完全一样，因此迁移可以分两步：

1. 在2.x版本代码库中随意使用`this.$scopedSlots`；
2. 在3.0版本中用`this.$slots`替换所有出现的`this.$scopeSlots`。